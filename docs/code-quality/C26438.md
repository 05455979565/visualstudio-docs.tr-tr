---
title: C26438
ms.date: 11/15/2017
ms.prod: visual-studio-dev15
ms.topic: conceptual
f1_keywords:
- C26438
helpviewer_keywords:
- C26438
ms.assetid: c7b3f59c-fb2f-4816-bda4-0fad23c80d83
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 1bc8a8923534ca2dd26f1f2f4726db2502ed69b8
ms.sourcegitcommit: 37fb7075b0a65d2add3b137a5230767aa3266c74
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/02/2019
ms.locfileid: "53849301"
---
# <a name="c26438-nogoto"></a>C26438 NO_GOTO
"'Goto' kullanmayın."

**C++ temel yönergeleri**: ES.76: Goto kaçının

'Goto' ' ı kullanarak tehlikeli ve hata yapmaya açık uygulama olarak yaygın olarak onaylanır. Üretilen kodda (dilbilgisini oluşturulan örneğin bir ayrıştırıcı) yalnızca içinde kullanılabilir. Modern C++ özellikleri ve yönerge destek kitaplığı tarafından sağlanan yardımcı programları 'goto' tamamen önlemek kolay olmalıdır.

## <a name="remarks"></a>Açıklamalar
- Hiçbir zaman kullanılır ve bu nedenle derleyici tarafından yok sayılır şablon kodunun dışında ölü kod durumda bile bu kural tüm 'goto', oluşumunu üzerinde sizi uyarır.
  - Uyarılar, 'goto' içeren bir makro karşılaşmaları durumunda gürültülü olabilir. Burada bu tür bir makro genişletilmiş tüm örnekleri için geçerli bir raporlama mekanizması noktasında olduğu. Ancak, düzeltme genellikle tek bir yerde makro değiştirme veya onu kullanmamanız ve daha fazla sürdürülebilir mekanizmaları yararlanarak yapılabilir.
    ## <a name="example"></a>Örnek
    'goto temizleme' makrosu

```cpp
#define ENSURE(E, L) if (!(E)) goto L;

void poll(connection &c)
{
    ENSURE(c.open(), end);                  // C26438

    while (c.wait())
    {
        connection::header h{};
        connection::signature s{};
        ENSURE(c.read_header(h), end);      // C26438
        ENSURE(c.read_signature(s), end);   // C26438
        // ...
    }

end:
    c.close();
}
```

## <a name="example"></a>Örnek
'goto temizleme' makrosu - gsl::finally ile değiştirildi

```cpp
void poll(connection &c)
{
    auto end = gsl::finally([&c] { c.close(); });

    if (!c.open())
        return;

    while (c.wait())
    {
        connection::header h{};
        connection::signature s{};
        if(!c.read_header(h))
            return;
       if(!c.read_signature(s))
            return;
        // ...
    }
}
```
