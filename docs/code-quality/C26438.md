---
title: C26438
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26438
helpviewer_keywords:
- C26438
ms.assetid: c7b3f59c-fb2f-4816-bda4-0fad23c80d83
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: ee3424728d7c46422e820961304bfcfe38ce678a
ms.sourcegitcommit: 21d667104199c2493accec20c2388cf674b195c3
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/08/2019
ms.locfileid: "55920255"
---
# <a name="c26438-nogoto"></a>C26438 NO_GOTO
"'Goto' kullanmayın."

**C++ temel yönergeleri**: ES.76: Goto kaçının

'Goto' ' ı kullanarak tehlikeli ve hata yapmaya açık uygulama olarak yaygın olarak onaylanır. Üretilen kodda (dilbilgisini oluşturulan örneğin bir ayrıştırıcı) yalnızca içinde kullanılabilir. Modern C++ özellikleri ve yönerge destek kitaplığı tarafından sağlanan yardımcı programları 'goto' tamamen önlemek kolay olmalıdır.

## <a name="remarks"></a>Açıklamalar
- Hiçbir zaman kullanılır ve bu nedenle derleyici tarafından yok sayılır şablon kodunun dışında ölü kod durumda bile bu kural tüm 'goto', oluşumunu üzerinde sizi uyarır.
  - Uyarılar, 'goto' içeren bir makro karşılaşmaları durumunda gürültülü olabilir. Burada bu tür bir makro genişletilmiş tüm örnekleri için geçerli bir raporlama mekanizması noktasında olduğu. Ancak, düzeltme genellikle tek bir yerde makro değiştirme veya onu kullanmamanız ve daha fazla sürdürülebilir mekanizmaları yararlanarak yapılabilir.
    ## <a name="example"></a>Örnek
    'goto temizleme' makrosu

```cpp
#define ENSURE(E, L) if (!(E)) goto L;

void poll(connection &c)
{
    ENSURE(c.open(), end);                  // C26438

    while (c.wait())
    {
        connection::header h{};
        connection::signature s{};
        ENSURE(c.read_header(h), end);      // C26438
        ENSURE(c.read_signature(s), end);   // C26438
        // ...
    }

end:
    c.close();
}
```

## <a name="example"></a>Örnek
'goto temizleme' makrosu - gsl::finally ile değiştirildi

```cpp
void poll(connection &c)
{
    auto end = gsl::finally([&c] { c.close(); });

    if (!c.open())
        return;

    while (c.wait())
    {
        connection::header h{};
        connection::signature s{};
        if(!c.read_header(h))
            return;
       if(!c.read_signature(s))
            return;
        // ...
    }
}
```
