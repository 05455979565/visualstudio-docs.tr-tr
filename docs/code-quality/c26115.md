---
title: C26115
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C26115
helpviewer_keywords:
- C26115
ms.assetid: 3977a2bb-d1fe-4510-89dd-07fdc69e911c
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: f1ec27364cea2887ab8cb5c0986a3b78a00b52ac
ms.sourcegitcommit: 485ffaedb1ade71490f11cf05962add1718945cc
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/16/2019
ms.locfileid: "72435093"
---
# <a name="c26115"></a>C26115
Uyarı C26115: kilit \<lock > \<func > işlevine serbest bırakılamadı.

 C/C++ programlarındaki sözdizimi kapsamlı kilit *alma* ve kilitleme *yayın* çiftlerini uygulama dil tarafından gerçekleştirilmez. Bir işlev, eşzamanlılık durumunda bir observable değişikliği yaparak bir kilitleme yan etkisi ortaya çıkarabilir. Örneğin, bir kilit sarmalayıcı işlevi, belirli bir kilit için kilit alma veya kilit sayısı sayısını artırır.

 Sırasıyla `_Acquires_lock_` veya `_Releases_lock_` kullanarak kilit alma veya kilitleme sürümünden yan etkisi olan bir işleve açıklama ekleyebilirsiniz. Bu ek açıklamalar olmadan, bir işlevin dönüşden sonra herhangi bir kilit sayısını değiştirmemelidir. Alma ve yayınlar dengeli değilse, *yalnız bırakılmış*oldukları kabul edilir. Bir işlev yalnız bırakılmış bir kilit oluşturduğunda uyarı C26115 verilir.

## <a name="example"></a>Örnek
 Aşağıdaki örnek, `_Acquires_lock_` ile açıklamalı olmayan bir işlevde yalnız bırakılmış bir kilit olduğundan, uyarı C26115 oluşturur.

```

typedef struct _DATA
{
    CRITICAL_SECTION cs;
} DATA;

void FailToReleaseLock(int flag, DATA* p)
{
    EnterCriticalSection(&p->cs);

    if (flag)
        return; // Warning C26115

    LeaveCriticalSection(&p->cs);
}
```
