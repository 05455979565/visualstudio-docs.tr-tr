---
title: 'CA2000: Kapsamı kaybetmeden önce verileri atın'
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
ms.assetid: 0c3d7d8d-b94d-46e8-aa4c-38df632c1463
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 387f1c3d763b15cdbf9ff3cc21375958dc213058
ms.sourcegitcommit: 4bcd6abb89feff1cf8251e3ded73fdc30b67e347
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/17/2020
ms.locfileid: "81615576"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a>CA2000: Kapsamı kaybetmeden önce verileri atın

|||
|-|-|
|TypeName|DisposeObjectsBeforeLosingScope|
|CheckId|CA2000|
|Kategori|Microsoft.Reliability|
|Son dakika değişikliği|Kırılmaz|

## <a name="cause"></a>Nedeni

Bir <xref:System.IDisposable> türün yerel nesnesi oluşturulur, ancak nesneye yapılan tüm başvurular kapsam dışına çıkmadan nesne atılmaz.

Varsayılan olarak, bu kural tüm kod tabanını çözümler, ancak bu [yapılandırılabilir.](#configurability)

## <a name="rule-description"></a>Kural açıklaması

Tek kullanımlık bir nesne, tüm başvurular kapsam dışına çıkmadan önce açıkça atılamazsa, çöp toplayıcı nesnenin sonlandırıcısını çalıştırdığında nesne belirsiz bir zamanda atılır. Nesnenin sonlandırıcısının çalışmasını engelleyecek istisnai bir olay oluşabileceğinden, nesne bunun yerine açıkça imha edilmelidir.

### <a name="special-cases"></a>Özel durumlar

CA2000 kuralı, nesne atılmasa bile aşağıdaki türdeki yerel nesneler için ateş açmaz:

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

Bu türlerden birinin nesnesinin bir oluşturucuya geçirilmesi ve bir alana atanması, yeni oluşturulan türe *elden çıkarma sahipliği aktarımını* gösterir. Diğer bir zamanda, yeni oluşturulan tür artık nesnenin atılmasından sorumludur. Kodunuz bu türlerden birinin nesnesini bir oluşturucuya geçirirse, nesne tüm başvurular kapsam dışında olmadan imha edilmese bile CA2000 kuralının ihlali gerçekleşmez.

## <a name="how-to-fix-violations"></a>İhlalleri düzeltme

Bu kuralın ihlalini düzeltmek <xref:System.IDisposable.Dispose%2A> için, tüm başvurular kapsam dışında olmadan nesneyi arayın.

Aşağıdakileri uygulayan <xref:System.IDisposable>nesneleri[`Using`](/dotnet/visual-basic/language-reference/statements/using-statement) sarmak için deyimi (Visual Basic'te) kullanabilirsiniz. [ `using` ](/dotnet/csharp/language-reference/keywords/using-statement) Bu şekilde sarılmış nesneler otomatik olarak `using` bloğun sonunda atılır. Ancak, aşağıdaki durumlar bir `using` deyimle ele alınmamalıdır veya ele alınmamalıdır:

- Tek kullanımlık bir nesneyi döndürmek `try/finally` için nesnenin `using` bloğun dışındaki bir blokta inşa etmesi gerekir.

- Tek kullanımlık bir nesnenin üyelerini bir `using` deyimin oluşturucusunda başlatmayın.

- Yalnızca bir özel durum işleyicisi tarafından korunan kurucular [bir `using` deyimin edinme bölümünde](/dotnet/csharp/language-reference/language-specification/statements#the-using-statement)iç içe geçtiğinde, dış yapı oluşturucudaki bir hata iç içe kurucu tarafından oluşturulan nesnenin hiçbir zaman kapatılmamasına neden olabilir. Aşağıdaki örnekte, <xref:System.IO.StreamReader> oluşturucudaki bir hata nesnenin <xref:System.IO.FileStream> hiç kapanmamasına neden olabilir. CA2000 bayrakları bu durumda kuralın ihlali.

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- Dinamik nesneler, nesnelerin elden çıkarma deseni <xref:System.IDisposable> uygulamak için bir gölge nesnesi kullanmalıdır.

## <a name="when-to-suppress-warnings"></a>Uyarıları ne zaman bastırır

Şu olmadıkça bu kuraldan gelen bir uyarıyı bastırmayın:

- Nesnenizde `Dispose`bir yöntem çağırdınız( örneğin,<xref:System.IO.Stream.Close%2A>
- Uyarıyı yükselten yöntem <xref:System.IDisposable> nesnenizi saran bir nesne döndürür
- Ayırma yönteminin elden çıkarma mülkiyeti yoktur; diğer bir deyişle, nesneyi elden çıkarma sorumluluğu yöntemde oluşturulan başka bir nesneye veya sarıcıya aktarılır ve arayana döndürülür

## <a name="configurability"></a>Konfigürasyon

Bu kuralı [FxCop çözümleyicilerinden](install-fxcop-analyzers.md) (eski çözümlemeyle değil) çalıştırıyorsanız, bu kural için çözümlemesi yapılandırabilirsiniz.

### <a name="excluded-symbol-names"></a>Dışlanan sembol adları

Kod tabanınızın hangi bölümlerini çözümlemeden hariç tutacağı nızı görebilirsiniz. Örneğin, kuralın adlı `MyType`türler içinde herhangi bir kodda çalışmaması gerektiğini belirtmek için, projenizdeki bir .editorconfig dosyasına aşağıdaki anahtar değer çiftini ekleyin:

```ini
dotnet_code_quality.CA2000.excluded_symbol_names = MyType
```

Seçenek değerinde izin verilen sembol adı biçimleri ('|' ile ayrılır):
  - Yalnızca sembol adı (içeren tür veya ad alanına bakılmaksızın, adı taşıyan tüm sembolleri içerir)
  - Sembolün [belgekimliği kimliği biçiminde](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)tam nitelikli adlar. Her sembol adı, yöntemler için "M:" öneki, türler için "T:" öneki, ad alanları için "N:" öneki vb. gibi bir sembol türü öneki gerektirir.
  - `.ctor`yapıcılar ve `.cctor` statik yapıcılar için

Örnekler:

| Opsiyon Değeri | Özet |
| --- | --- |
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType` | Derlemede 'MyType' adlı tüm sembollerle eşleşir
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType1|MyType2` | Derlemede 'MyType1' veya 'MyType2' adlı tüm sembollerle eşleşir
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Belirli bir yöntem 'MyMethod' tam nitelikli imza verilen maçlar
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Belirli yöntemler 'MyMethod1' ve 'MyMethod2' ile ilgili tam nitelikli imzaile eşleşir

Tüm bu seçenekleri yalnızca bu kural için, tüm kurallar için veya bu kategorideki tüm kurallar için yapılandırabilirsiniz (Tasarım). Daha fazla bilgi için Bkz. [Bkz.](configure-fxcop-analyzers.md)

## <a name="related-rules"></a>İlgili kurallar

- [CA2213: Atılabilen alanlar atılmalıdır](../code-quality/ca2213.md)
- [CA2202: Nesneleri birden çok kez atmayın](../code-quality/ca2202.md)

## <a name="example"></a>Örnek

Tek kullanımlık bir nesne döndüren bir yöntem uyguluyorsanız, nesnenin atıldığından emin olmak için catch bloğu olmadan deneme/son engelleme kullanın. Deneme/son engelleme kullanarak, hata noktasında özel durumların yükseltilmesine izin verir siniz ve nesnenin atıldığından emin olun.

OpenPort1 yönteminde, ISerializable nesneSerialPort'u açma çağrısı veya SomeMethod'a yapılan çağrı başarısız olabilir. Bu uygulama da CA2000 uyarısı gündeme getirilir.

OpenPort2 yönteminde, iki SerialPort nesnesi bildirilir ve null olarak ayarlanır:

- `tempPort`, yöntem işlemlerinin başarılı olduğunu test etmek için kullanılır.

- `port`, yöntemin geri dönüş değeri için kullanılır.

Bir `tempPort` `try` blokta inşa edilir ve açılır ve gerekli diğer `try` işler aynı blokta gerçekleştirilir. `try` Bloğun sonunda, açılan bağlantı noktası döndürülecek `port` nesneye atanır ve `tempPort` nesne `null`.

Blok `finally` değerini `tempPort`denetler. Null değilse, yöntemdeki bir işlem başarısız oldu `tempPort` ve herhangi bir kaynağın serbest bırakıldığından emin olmak için kapatıldı. Döndürülen bağlantı noktası nesnesi, yöntemin işlemleri başarılı olursa, açılan SerialPort nesnesini içerir veya bir işlem başarısız olursa geçersiz olur.

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example"></a>Örnek

Varsayılan olarak, Visual Basic derleyicisi tüm aritmetik işleçleri taşma için kontrol vardır. Bu nedenle, herhangi bir Visual Basic <xref:System.OverflowException>aritmetik işlem bir . Bu, CA2000 gibi kurallarda beklenmeyen ihlallere yol açabilir. Örneğin, Visual Basic derleyicisi StreamReader'ın atılmamasına neden olabilecek bir özel durum oluşturabilecek ekleme için taşma denetleme yönergesi yaydığından, aşağıdaki CreateReader1 işlevi CA2000 ihlali oluşturur.

Bunu düzeltmek için, projenizdeki Visual Basic derleyicisi tarafından taşma denetimlerinin yayan devre dışı bırakabilirsiniz veya kodunuzu aşağıdaki CreateReader2 işlevinde olduğu gibi değiştirebilirsiniz.

Taşma denetimlerinin yayı girişini devre dışı ksaymak için, Çözüm Gezgini'nde proje adını sağ tıklatın ve ardından **Özellikler'i**tıklatın. **Derle'i**tıklatın, **Gelişmiş Derleme Seçenekleri'ni**tıklatın ve sonra **tamsayı taşmasını denetle'yi denetleyin' i**denetleyin.

[!code-vb[FxCop.Reliability.CA2000.DisposeObjectsBeforeLosingScope#1](../code-quality/codesnippet/VisualBasic/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb)]

## <a name="see-also"></a>Ayrıca bkz.

- <xref:System.IDisposable>
- [Dispose Deseni](/dotnet/standard/design-guidelines/dispose-pattern)
