---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: ea1e4a708765a173231689cd9c2037a4a20158af
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/07/2019
ms.locfileid: "72016625"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

Bu denetim *rule I. 11 ' I zorlamaya yardımcı olur: Sahipliği hiçbir şekilde bir ham işaretçi (T @ no__t-0)*  ' dir. bu kuralın bir alt kümesi olan *R. 3: Ham işaretçi (T @ no__t-0) sahip değil.* Özellikle, `new` işlecine yapılan herhangi bir çağrı üzerinde sizi uyarır. Bu, sonucunu ham işaretçi türünde bir değişkende kaydeder. Ayrıca, sonuçları ham işaretçilere atandığında `gsl::owner<T>` döndüren işlevlere yapılan çağrılar üzerinde de uyarır. Buradaki fikir, bellek kaynaklarının sahipliğini açık bir şekilde sağlamalısınız. Daha fazla bilgi için bkz. [ C++ temel yönergeler](http://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

Bunu gidermenin en kolay yolu, kaynak değişken bildiriminde hemen atanırsa `auto` bildirimini kullanmaktır. Bu mümkün değilse, `gsl::owner<T>` türünü kullanmanızı öneririz. @No__t-1 işleci ile başlatılan `auto` bildirimleri "sahipler", çünkü herhangi bir ayırmanın sonucunun örtük olarak bir sahip işaretçisi olduğunu varsaydık. Bu varsayımını `auto` değişkenine aktardık ve `owner<T>` olarak kabul ediyoruz.

Bu denetim, `owner<T>` döndüren bir işleve yapılan çağrıyı işaret ediyor, bu, koddaki meşru bir hata göstergesi olabilir. Temel olarak, kodun açık bir sahiplik kavramı (ve belki de kaynağın kendisi) olduğu bir yere işaret eder.

## <a name="remarks"></a>Açıklamalar

Bu kural şu anda yalnızca yerel değişkenleri denetliyor. Ayırma bir biçimsel parametreye, genel değişkene, sınıf üyesine ve bu şekilde atanmışsa, bayrak uygulanmaz. Bu senaryoların uygun kapsamı, gelecekteki çalışmanın bir parçasıdır.

## <a name="example-1-simple-allocation"></a>Örnek 1: Basit ayırma

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>Örnek 2: Basit ayırma (GSL:: Owner ile düzeltildi @ no__t-0T >)

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
