---
title: C6220
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6220
helpviewer_keywords:
- C6220
ms.assetid: a13524f4-0a1f-4670-b830-70b06e4d39d2
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 283e2d5643dbf6f595a0cea318a7db189442ddd9
ms.sourcegitcommit: 485ffaedb1ade71490f11cf05962add1718945cc
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/16/2019
ms.locfileid: "72445062"
---
# <a name="c6220"></a>C6220
Uyarı C6220-anlamsal olarak farklı tamsayı türleri arasında örtük atama: HRESULT,-1 ile karşılaştırılıyor. Bunun yerine başarılı veya başarısız makro kullanmayı düşünün

 Bu uyarı, `HRESULT` ' ın, iyi biçimlendirilmiş bir `HRESULT` olmayan açık, `HRESULT` olmayan bir değer ile karşılaştırıldığını gösterir. @No__t-0 (`E_FAIL`) içindeki bir hata,-1 ile temsil edilmez. Bu nedenle, `HRESULT` ' a bir tamsayıya örtük bir şekilde dönüştürme yanlış bir değer oluşturur ve büyük olasılıkla yanlış sonuca yol açacaktır.

## <a name="example"></a>Örnek
 Çoğu durumda, bu uyarı, bir @no__t döndüren bir işlevin bir hata değeri olarak-1 ' i kullanarak bir tamsayı döndürmesi beklenirken yanlışlıkla kod tarafından neden olur. Aşağıdaki kod örneği bu uyarıyı oluşturur:

```
#include <windows.h>

HRESULT f( )
{
  HRESULT hr;
  LPMALLOC pMalloc;

  hr = CoGetMalloc(1, &pMalloc);
  if (hr == -1)
  {
    // failure code ...
    return E_FAIL;
  }
  else
  {
    // success code ...
    return S_OK;
  }
}
```

 Bir `HRESULT` değerini test etmek için `SUCCEEDED` veya `FAILED` makrosunu kullanmak en iyisidir. Bu uyarıyı düzeltmek için aşağıdaki kodu kullanın:

```
#include <windows.h>

HRESULT f( )
{
  HRESULT hr;
  LPMALLOC pMalloc;

  hr = CoGetMalloc(1, &pMalloc);
  if (FAILED(hr))
  {
    // failure code ...
    return E_FAIL;
  }
  else
  {
    // success code ...
    return S_OK;
  }
}
```

 Bu uyarı için `SCODE` türü `HRESULT` ' e eşdeğerdir.

 Açık karşılaştırma, `E_FAIL` gibi belirli @no__t 0 değerlerini denetlemek için uygundur. Aksi takdirde, `SUCCEEDED` veya `FAILED` makrolarını kullanın.

 Daha fazla bilgi için bkz. [başarılı makro](http://go.microsoft.com/fwlink/?LinkId=92738) ve [başarısız makro](http://go.microsoft.com/fwlink/?LinkId=180875).

 Malloc ve Free (ve ilgili dinamik bellek ayırma API 'Leri) kullanmanın, bellek sızıntıları ve özel durumlar açısından birçok gizli dizi olduğunu unutmayın. Bu tür sızıntıları ve özel durum sorunlarını tamamen önlemek için, C++ standart şablon KITAPLıĞı (STL) tarafından sunulan mekanizmaları kullanın. Bunlar şunlardır [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class)ve [Vector](/cpp/standard-library/vector). Daha fazla bilgi için bkz. [akıllı işaretçiler](/cpp/cpp/smart-pointers-modern-cpp) ve [ C++ standart kitaplık](/cpp/standard-library/cpp-standard-library-reference).
