---
title: 'CA2006: Yerel kaynakları kapsamak için SafeHandle kullanın'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA2006
- UseSafeHandleToEncapsulateNativeResources
helpviewer_keywords:
- UseSafeHandleToEncapsulateNativeResources
- CA2006
ms.assetid: a71950bd-bcc1-463d-b1f2-5233bc451456
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- cplusplus
ms.openlocfilehash: 7c75f48c56b21d50e08e9864557318d7f110edae
ms.sourcegitcommit: d233ca00ad45e50cf62cca0d0b95dc69f0a87ad6
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/01/2020
ms.locfileid: "75584640"
---
# <a name="ca2006-use-safehandle-to-encapsulate-native-resources"></a>CA2006: Yerel kaynakları kapsamak için SafeHandle kullanın

|||
|-|-|
|TypeName|UseSafeHandleToEncapsulateNativeResources|
|CheckId|CA2006|
|Kategori|Microsoft. güvenilirliği|
|Son değişiklik|Kırılmamış|

## <a name="cause"></a>Sebep

Yönetilen kod, yerel kaynaklara erişmek için <xref:System.IntPtr> kullanır.

## <a name="rule-description"></a>Kural açıklaması

Yönetilen kodda `IntPtr` kullanımı, olası bir güvenlik ve güvenilirlik sorununu gösterebilir. `IntPtr` tüm kullanımları, onun yerine <xref:System.Runtime.InteropServices.SafeHandle> veya benzer bir teknolojinin kullanılması gerekip gerekmediğini belirleyebilmek için incelenmelidir. `IntPtr`, bellek, dosya tanıtıcısı veya bir yuva gibi bir yerel kaynağı temsil ediyorsa, yönetilen kodun sahip olarak kabul edildiği sorunlar meydana gelir. Yönetilen kod kaynağın sahibi ise, bunun bir hata olması durumunda kaynak sızıntısı oluşmasına neden olacağından, onunla ilişkili yerel kaynakları da serbest bırakmalıdır.

Bu tür senaryolarda, çok iş parçacıklı erişime `IntPtr` ve `IntPtr` tarafından temsil edilen kaynağı serbest bırakma bir yolu sağlandığında güvenlik veya güvenilirlik sorunları da mevcut olacaktır. Bu sorunlar, kaynağın eşzamanlı kullanımı başka bir iş parçacığında yapıldığında kaynak sürümündeki `IntPtr` değerinin geri dönüşümünü içerir. Bu, bir iş parçacığının yanlış kaynakla ilişkili verileri okuyabildiği veya yazabileceği yarış koşullarına neden olabilir. Örneğin, türünüz bir `IntPtr` olarak bir işletim sistemi tanıtıcısı depoluyorsa ve kullanıcıların her ikisini de ve bu tanıtıcıyı kullanan başka bir yöntemi aynı **anda ve bir** tür eşitleme olmadan çağırabilmesini sağlar, kodunuzun bir tanıtıcı geri dönüştürme sorunu vardır.

Bu tanıtıcı geri dönüştürme sorunu, verilerin bozulmasına ve sıklıkla bir güvenlik açığına neden olabilir. `SafeHandle` ve eşdüzey sınıfı <xref:System.Runtime.InteropServices.CriticalHandle>, bu iş parçacığı sorunlarının önlenebilir olması için bir kaynağa yerel tanıtıcıyı kapsüllemek için bir mekanizma sağlar. Ek olarak, diğer iş parçacığı sorunları için `SafeHandle` ve eşdüzey sınıf `CriticalHandle` kullanabilirsiniz. Örneğin, yerel bir tanıtıcının bir kopyasını içeren yönetilen nesnelerin ömrünü dikkatlice denetlemek için yerel yöntemlere çağrılar yapılır. Bu durumda, `GC.KeepAlive`çağrıları genellikle kaldırabilirsiniz. `SafeHandle` kullandığınızda ve `CriticalHandle`daha az bir dereceye kadar yaptığınız performans yükü, dikkatli bir tasarım aracılığıyla sık azaltılabilir.

## <a name="how-to-fix-violations"></a>İhlalleri çözme

Yerel kaynaklara erişimi güvenle yönetmek için `IntPtr` kullanımını `SafeHandle` olarak dönüştürün. Örnekler için <xref:System.Runtime.InteropServices.SafeHandle> başvuru makalesine bakın.

## <a name="when-to-suppress-warnings"></a>Uyarıların ne zaman bastırılamıyor

Bu uyarıyı bastırmayın.

## <a name="see-also"></a>Ayrıca bkz.

- <xref:System.IDisposable>
